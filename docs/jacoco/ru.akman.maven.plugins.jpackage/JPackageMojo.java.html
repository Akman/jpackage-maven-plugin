<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JPackageMojo.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JPackage Maven Plugin</a> &gt; <a href="index.source.html" class="el_package">ru.akman.maven.plugins.jpackage</a> &gt; <span class="el_source">JPackageMojo.java</span></div><h1>JPackageMojo.java</h1><pre class="source lang-java linenums">/*
  Copyright (C) 2020 - 2022 Alexander Kapitman

  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/

package ru.akman.maven.plugins.jpackage;

import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.PathMatcher;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Properties;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.apache.commons.lang3.JavaVersion;
import org.apache.commons.lang3.StringUtils;
import org.apache.maven.artifact.Artifact;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugins.annotations.Component;
import org.apache.maven.plugins.annotations.Execute;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.plugins.annotations.ResolutionScope;
import org.apache.maven.shared.model.fileset.FileSet;
import org.codehaus.plexus.languages.java.jpms.JavaModuleDescriptor;
import org.codehaus.plexus.languages.java.jpms.LocationManager;
import org.codehaus.plexus.languages.java.jpms.ModuleNameSource;
import org.codehaus.plexus.languages.java.jpms.ResolvePathsRequest;
import org.codehaus.plexus.languages.java.jpms.ResolvePathsResult;
import org.codehaus.plexus.util.FileUtils;
import org.codehaus.plexus.util.cli.CommandLineException;
import org.codehaus.plexus.util.cli.Commandline;
import ru.akman.maven.plugins.BaseToolMojo;
import ru.akman.maven.plugins.CommandLineBuilder;
import ru.akman.maven.plugins.CommandLineOption;

/**
 * The jpackage goal lets you create a custom runtime image with
 * the jpackage tool introduced in Java 13.
 *
 * &lt;p&gt;
 * The main idea is to avoid being tied to project artifacts and allow the user
 * to fully control the process of creating an image.
 * &lt;/p&gt;
 */
@Mojo(
    name = &quot;jpackage&quot;,
    requiresDependencyResolution = ResolutionScope.RUNTIME
//    defaultPhase = LifecyclePhase.VERIFY,
//    requiresProject = true,
//    aggregator = &lt;false|true&gt;,
//    configurator = &quot;&lt;role hint&gt;&quot;,
//    executionStrategy = &quot;&lt;once-per-session|always&gt;&quot;,
//    inheritByDefault = &lt;true|false&gt;,
//    instantiationStrategy = InstantiationStrategy.&lt;strategy&gt;,
//    requiresDependencyCollection = ResolutionScope.&lt;scope&gt;,
//    requiresDirectInvocation = &lt;false|true&gt;,
//    requiresOnline = &lt;false|true&gt;,
//    threadSafe = &lt;false|true&gt;,
)
// @Execute(
//    This will fork an alternate build lifecycle up to the specified phase
//    before continuing to execute the current one.
//    If no lifecycle is specified, Maven will use the lifecycle
//    of the current build.
//    phase = LifecyclePhase.VERIFY
//
//    This will execute the given goal before execution of this one.
//    The goal name is specified using the prefix:goal notation.
//    goal = &quot;prefix:goal&quot;
//
//    This will execute the given alternate lifecycle. A custom lifecycle
//    can be defined in META-INF/maven/lifecycle.xml.
//    lifecycle = &quot;&lt;lifecycle&gt;&quot;, phase=&quot;&lt;phase&gt;&quot;
// )
<span class="fc" id="L98">public class JPackageMojo extends BaseToolMojo {</span>

  /**
   * The name of the subdirectory where the tool live.
   */
  private static final String TOOL_HOME_BIN = &quot;bin&quot;;

  /**
   * The tool name.
   */
  private static final String TOOL_NAME = &quot;jpackage&quot;;

  /**
   * Filename for temporary file contains the tool options.
   */
  private static final String OPTS_FILE = TOOL_NAME + &quot;.opts&quot;;

  /**
   * Filename of a module descriptor.
   */
  private static final String DESCRIPTOR_NAME = &quot;module-info.class&quot;;

  /**
   * Filename prefix for temporary file contains the launcher properties.
   */
  private static final String PROPS_PREFIX = &quot;launcher.&quot;;

  /**
   * Filename suffix for temporary file contains the launcher properties.
   */
  private static final String PROPS_SUFFIX = &quot;.properties&quot;;

  /**
   * The line ending pattern.
   */
  private static final String SPACES_PATTERN = &quot;\\s+&quot;;

  /**
   * The char that will used to wrap an option string.
   */
  private static final char WRAP_CHAR = '\'';

  /**
   * Error message pattern for unability to resolve file path.
   */
  private static final String ERROR_RESOLVE =
      &quot;Error: Unable to resolve file path for {0} [{1}]&quot;;

  /**
   * List of temporary files.
   */
<span class="fc" id="L149">  private final List&lt;File&gt; tempFiles = new ArrayList&lt;&gt;();</span>

  /**
   * Resolved project dependencies.
   */
  private ResolvePathsResult&lt;File&gt; projectDependencies;

  /**
   * Resolved main module descriptor.
   */
  private JavaModuleDescriptor mainModuleDescriptor;

  /**
   * JPMS location manager.
   */
  @Component
  private LocationManager locationManager;

  /**
   * Specifies the path to the JDK home directory providing the tool needed.
   */
  @Parameter
  private File toolhome;


  // generic options


  /**
   * Specifies the location in which generated output files are placed.
   *
   * &lt;em&gt;BUG: A path cannot contain spaces and unicode characters.&lt;/em&gt;
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--dest path&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;${project.build.directory}/jpackage&quot;
  )
  private File dest;

  /**
   * Specifies the location in which temporary files are placed.
   * If specified, the directory will not be removed upon the task
   * completion and must be removed manually.
   *
   * &lt;em&gt;BUG: A path cannot contain spaces and unicode characters.&lt;/em&gt;
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--temp path&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private File temp;

  /**
   * Specifies the type of package
   * to create: { 'PLATFORM', 'IMAGE', 'EXE', 'MSI' }.
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--type {app-image|exe|msi}&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;PLATFORM&quot;
  )
  private PackageType type;

  /**
   * Enable verbose tracing.
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--verbose&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;false&quot;
  )
  private boolean verbose;

  /**
   * Specifies version of the application and/or package.
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--app-version version&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private String appversion;

  /**
   * Specifies copyright for the application.
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--copyright copyright&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private String copyright;

  /**
   * Specifies description of the application.
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--description description&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private String description;

  /**
   * Specifies the name of subdirectory relative to the destination
   * directory in which files of generated application image are placed.
   *
   * &lt;em&gt;BUG: A name cannot contain spaces and unicode characters.&lt;/em&gt;
   * &lt;em&gt;BUG: The names used to create the application image and
   * the application installer must match.&lt;/em&gt;
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--name directory-name&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private String name;

  /**
   * Specifies vendor of the application.
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--vendor vendor&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private String vendor;


  // options for creating the application image


  /**
   * Specifies the location of the icon of the application launcher.
   *
   * &lt;em&gt;BUG: A path cannot contain spaces and unicode characters.&lt;/em&gt;
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--icon path&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private File icon;

  /**
   * Specifies the location of the input directory that contains
   * the files to be packaged. All files in the input directory
   * will be packaged into the application image into $APPDIR directory.
   *
   * &lt;em&gt;BUG: A path cannot contain spaces and unicode characters.&lt;/em&gt;
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--input path&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private File input;


  // options for creating the runtime image


  /**
   * Specifies the location of the predefined runtime image (result of jlink)
   * that will be copied into the application image.
   * If not specified, jpackage will run jlink to create
   * the runtime image using options:
   *   - &lt;code&gt;--strip-debug&lt;/code&gt;
   *   - &lt;code&gt;--no-header-files&lt;/code&gt;
   *   - &lt;code&gt;--no-man-pages&lt;/code&gt;
   *   - &lt;code&gt;--strip-native-commands&lt;/code&gt;
   *
   * &lt;em&gt;BUG: A path cannot contain spaces and unicode characters.&lt;/em&gt;
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--runtime-image path&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private File runtimeimage;

  /**
   * Specifies the module path. The path where the jlink tool discovers
   * observable modules: modular JAR files, JMOD files, exploded modules.
   * If this option is not specified, then the default module path
   * is $JAVA_HOME/jmods. This directory contains the java.base module
   * and the other standard and JDK modules. If this option is specified
   * but the java.base module cannot be resolved from it, then
   * the jlink command appends $JAVA_HOME/jmods to the module path.
   * Pass on --modulepath option to jlink.
   *
   * &lt;p&gt;
   * pathelements - passed to jlink as is
   * filesets - sets of files (without directories)
   * dirsets - sets of directories (without files)
   * dependencysets - sets of dependencies with specified includes and
   *                  excludes patterns (glob: or regex:) for file names
   *                  and regex patterns only for module names
   * &lt;/p&gt;
   *
   * &lt;p&gt;&lt;pre&gt;
   * &amp;lt;modulepath&amp;gt;
   *   &amp;lt;pathelements&amp;gt;
   *     &amp;lt;pathelement&amp;gt;mod.jar&amp;lt;/pathelement&amp;gt;
   *     &amp;lt;pathelement&amp;gt;mod.jmod&amp;lt;/pathelement&amp;gt;
   *     &amp;lt;pathelement&amp;gt;mods/exploded/mod&amp;lt;/pathelement&amp;gt;
   *   &amp;lt;/pathelements&amp;gt;
   *   &amp;lt;filesets&amp;gt;
   *     &amp;lt;fileset&amp;gt;
   *       &amp;lt;directory&amp;gt;${project.build.directory}&amp;lt;/directory&amp;gt;
   *       &amp;lt;includes&amp;gt;
   *         &amp;lt;include&amp;gt;*&amp;#42;/*&amp;lt;/include&amp;gt;
   *       &amp;lt;/includes&amp;gt;
   *       &amp;lt;excludes&amp;gt;
   *         &amp;lt;exclude&amp;gt;*&amp;#42;/*Empty.jar&amp;lt;/exclude&amp;gt;
   *       &amp;lt;/excludes&amp;gt;
   *       &amp;lt;followSymlinks&amp;gt;false&amp;lt;/followSymlinks&amp;gt;
   *     &amp;lt;/fileset&amp;gt;
   *   &amp;lt;/filesets&amp;gt;
   *   &amp;lt;dirsets&amp;gt;
   *     &amp;lt;dirset&amp;gt;
   *       &amp;lt;directory&amp;gt;target&amp;lt;/directory&amp;gt;
   *       &amp;lt;includes&amp;gt;
   *         &amp;lt;include&amp;gt;*&amp;#42;/*&amp;lt;/include&amp;gt;
   *       &amp;lt;/includes&amp;gt;
   *       &amp;lt;excludes&amp;gt;
   *         &amp;lt;exclude&amp;gt;*&amp;#42;/*Test&amp;lt;/exclude&amp;gt;
   *       &amp;lt;/excludes&amp;gt;
   *       &amp;lt;followSymlinks&amp;gt;true&amp;lt;/followSymlinks&amp;gt;
   *     &amp;lt;/dirset&amp;gt;
   *   &amp;lt;/dirsets&amp;gt;
   *   &amp;lt;dependencysets&amp;gt;
   *     &amp;lt;dependencyset&amp;gt;
   *       &amp;lt;includeoutput&amp;gt;false&amp;lt;/includeoutput&amp;gt;
   *       &amp;lt;excludeautomatic&amp;gt;false&amp;lt;/excludeautomatic&amp;gt;
   *       &amp;lt;includes&amp;gt;
   *         &amp;lt;include&amp;gt;glob:*&amp;#42;/*.jar&amp;lt;/include&amp;gt;
   *         &amp;lt;include&amp;gt;regex:foo-(bar|baz)-.*?\.jar&amp;lt;/include&amp;gt;
   *       &amp;lt;/includes&amp;gt;
   *       &amp;lt;includenames&amp;gt;
   *         &amp;lt;includename&amp;gt;.*&amp;lt;/includename&amp;gt;
   *       &amp;lt;/includenames&amp;gt;
   *       &amp;lt;excludes&amp;gt;
   *         &amp;lt;exclude&amp;gt;glob:*&amp;#42;/javafx.*Empty&amp;lt;/exclude&amp;gt;
   *       &amp;lt;/excludes&amp;gt;
   *       &amp;lt;excludenames&amp;gt;
   *         &amp;lt;excludename&amp;gt;javafx\..+Empty&amp;lt;/excludename&amp;gt;
   *       &amp;lt;/excludenames&amp;gt;
   *     &amp;lt;/dependencyset&amp;gt;
   *   &amp;lt;/dependencysets&amp;gt;
   * &amp;lt;/modulepath&amp;gt;
   * &lt;/pre&gt;&lt;/p&gt;
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--modulepath path&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private ModulePath modulepath;

  /**
   * Specifies the modules names (names of root modules) to add to
   * the runtime image. Their transitive dependencies will add too.
   * This module list, along with the main module (if specified)
   * will be passed to jlink as the --add-module argument.
   * If not specified, either just the main module (if module is specified),
   * or the default set of modules (if mainjar is specified) are used.
   *
   * &lt;p&gt;&lt;pre&gt;
   * &amp;lt;addmodules&amp;gt;
   *   &amp;lt;addmodule&amp;gt;java.base&amp;lt;/addmodule&amp;gt;
   *   &amp;lt;addmodule&amp;gt;org.example.rootmodule&amp;lt;/addmodule&amp;gt;
   * &amp;lt;/addmodules&amp;gt;
   * &lt;/pre&gt;&lt;/p&gt;
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--add-modules module [, module...]&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private List&lt;String&gt; addmodules;

  /**
   * Link service provider modules and their dependencies.
   * Pass on --bind-services option to jlink.
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--bind-services&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;false&quot;
  )
  private boolean bindservices;


  // options for creating the application launcher(s)


  /**
   * Specifies the main module (and optionally main class) of
   * the application. This module must be located on the module path.
   * When this option is specified, the main module will be linked
   * in the Java runtime image. Either module or mainjar option
   * can be specified but not both.
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--module module-name[/class-name]&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private String module;

  /**
   * Specifies the main JAR of the application, specified as a path
   * relative to the input path, containing the main class.
   * Either module or mainjar option can be specified but not both.
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--main-jar jar-name&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private String mainjar;

  /**
   * Specifies the qualified name of the application main class to execute.
   * This option can only be used if mainjar is specified.
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--main-class class-name&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private String mainclass;

  /**
   * Specifies the command line arguments to pass to the main class
   * if no command line arguments are given to the launcher.
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--arguments args&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private String arguments;

  /**
   * Specifies the options to pass to the Java runtime.
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--java-options opts&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private String javaoptions;

  /**
   * Specifies options are added to, or used to overwrite, the original
   * command line options to build additional alternative launchers.
   *
   * &lt;em&gt;BUG: A path cannot contain spaces and unicode characters.&lt;/em&gt;
   *
   * &lt;p&gt;&lt;pre&gt;
   * &amp;lt;addlaunchers&amp;gt;
   *   &amp;lt;addlauncher&amp;gt;
   *     &amp;lt;name&amp;gt;launcher1&amp;lt;/name&amp;gt;
   *     &amp;lt;file&amp;gt;config/jpackage/launcher1.properties&amp;lt;/file&amp;gt;
   *     &amp;lt;module&amp;gt;mainModule1Name/mainClass1Name&amp;lt;/module&amp;gt;
   *     &amp;lt;mainjar&amp;gt;mainJar1.jar&amp;lt;/mainjar&amp;gt;
   *     &amp;lt;mainclass&amp;gt;mainClass1Name&amp;lt;/mainclass&amp;gt;
   *     &amp;lt;arguments&amp;gt;--arg11 --arg12&amp;lt;/arguments&amp;gt;
   *     &amp;lt;javaoptions&amp;gt;-Xms128m -Xmx1024m&amp;lt;/javaoptions&amp;gt;
   *     &amp;lt;appversion&amp;gt;1.0.1&amp;lt;/appversion&amp;gt;
   *     &amp;lt;icon&amp;gt;config/jpackage/launcher1.ico&amp;lt;/icon&amp;gt;
   *     &amp;lt;winconsole&amp;gt;true&amp;lt;/winconsole&amp;gt;
   *   &amp;lt;/addlauncher&amp;gt;
   * &amp;lt;/addlaunchers&amp;gt;
   * &lt;/pre&gt;&lt;/p&gt;
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--add-launcher name=path&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private List&lt;Launcher&gt; addlaunchers;


  // platform dependent option for creating the application launcher


  /**
   * Enable creating a console launcher for the application, should be
   * specified for application which requires console interactions.
   *
   * &lt;p&gt;The jlink CLI is: &lt;code&gt;--win-console&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;false&quot;
  )
  private boolean winconsole;


  // options for creating the application installable package


  /**
   * Specifies the location of the predefined application image that is used
   * to build an installable package.
   *
   * &lt;em&gt;BUG: A path cannot contain spaces and unicode characters.&lt;/em&gt;
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--app-image path&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private File appimage;

  /**
   * Specifies the location of a properties file that contains list of key,
   * value pairs. The keys &quot;extension&quot;, &quot;mime-type&quot;, &quot;icon&quot;, and &quot;description&quot;
   * can be used to describe the association.
   *
   * &lt;p&gt;&lt;pre&gt;
   * &amp;lt;fileassociations&amp;gt;
   *   &amp;lt;fileassociation&amp;gt;assoc1.properties&amp;lt;/fileassociation&amp;gt;
   *   &amp;lt;fileassociation&amp;gt;assoc2.properties&amp;lt;/fileassociation&amp;gt;
   * &amp;lt;/fileassociations&amp;gt;
   * &lt;/pre&gt;&lt;/p&gt;
   *
   * &lt;em&gt;BUG: A path cannot contain spaces and unicode characters.&lt;/em&gt;
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--file-associations path&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private List&lt;File&gt; fileassociations;

  /**
   * Specifies the relative sub-path under the default installation
   * location of the application for Windows, or absolute path of the
   * installation directory of the application for Mac or Linux.
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--install-dir name&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private String installdir;

  /**
   * Specifies the location of a license file.
   *
   * &lt;em&gt;BUG: A path cannot contain spaces and unicode characters.&lt;/em&gt;
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--license-file path&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private File licensefile;

  /**
   * Specifies the location of a resources directory that override
   * jpackage resources. Icons, template files, and other resources
   * of jpackage can be overridden by adding replacement resources
   * to this directory.
   *
   * &lt;em&gt;BUG: A path cannot contain spaces and unicode characters.&lt;/em&gt;
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--resource-dir path&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private File resourcedir;


  // platform dependent options for creating the application
  // installable package (Windows)


  /**
   * Enable adding a dialog to choose a directory in which
   * the product is installed.
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--win-dir-chooser&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;false&quot;
  )
  private boolean windirchooser;

  /**
   * Enable adding the application to the system menu.
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--win-menu&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;false&quot;
  )
  private boolean winmenu;

  /**
   * Start menu group this application is placed in.
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--win-menu-group name&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private String winmenugroup;

  /**
   * Enable requesting to perform an install on a per-user basis.
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--win-per-user-install&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;false&quot;
  )
  private boolean winperuserinstall;

  /**
   * Enable creating a desktop shortcut for the application.
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--win-shortcut&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter(
      defaultValue = &quot;false&quot;
  )
  private boolean winshortcut;

  /**
   * UUID associated with upgrades for this package.
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--win-upgrade-uuid uuid&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private String winupgradeuuid;


  // platform dependent options for creating the application
  // installable package (Mac)


  /**
   * An identifier that uniquely identifies the application for macOS.
   * Defaults to the main class name. May only use alphanumeric (A-Z,a-z,0-9),
   * hyphen (-), and period (.) characters.
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--mac-package-identifier id&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private String macpackageidentifier;

  /**
   * Name of the application as it appears in the Menu Bar.
   * This can be different from the application name.
   * This name must be less than 16 characters long and be suitable for
   * displaying in the menu bar and the application Info window.
   * Defaults to the application name.
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--mac-package-name name&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private String macpackagename;

  /**
   * When signing the application package, this value is prefixed
   * to all components that need to be signed that don't have
   * an existing package identifier.
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--mac-package-signing-prefix prefix&lt;/code&gt;
   * &lt;/p&gt;
   */
  @Parameter
  private String macpackagesigningprefix;

  /**
   * Request that the package be signed.
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--mac-sign&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private boolean macsign;

  /**
   * Path of the keychain to search for the signing identity
   * (absolute path or relative to the current directory).
   * If not specified, the standard keychains are used.
   *
   * &lt;em&gt;BUG: A path cannot contain spaces and unicode characters.&lt;/em&gt;
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--mac-signing-keychain path&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private File macsigningkeychain;

  /**
   * Team name portion in Apple signing identities' names.
   * For example &quot;Developer ID Application: &quot;.
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--mac-signing-key-user-name name&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private String macsigningkeyusername;


  // platform dependent options for creating the application
  // installable package (Linux)


  /**
   * Name for Linux package, defaults to the application name.
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--linux-package-name name&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private String linuxpackagename;

  /**
   * Maintainer for .deb package.
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--linux-deb-maintainer email&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private String linuxdebmaintainer;

  /**
   * Menu group this application is placed in.
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--linux-menu-group name&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private String linuxmenugroup;

  /**
   * Required packages or capabilities for the application.
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--linux-package-deps&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private boolean linuxpackagedeps;

  /**
   * Type of the license (&quot;License: name&quot; of the RPM .spec).
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--linux-rpm-license-type name&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private String linuxrpmlicensetype;

  /**
   * Release value of the RPM name.spec file or Debian revision value
   * of the DEB control file.
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--linux-app-release name&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private String linuxapprelease;

  /**
   * Group value of the RPM name.spec file or Section value
   * of DEB control file.
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--linux-app-category name&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private String linuxappcategory;

  /**
   * Creates a shortcut for the application.
   *
   * &lt;p&gt;The jpackage CLI is: &lt;code&gt;--linux-shortcut&lt;/code&gt;&lt;/p&gt;
   */
  @Parameter
  private boolean linuxshortcut;

  /**
   * Process options.
   *
   * @param cmdLine the command line builder
   *
   * @throws MojoExecutionException if any errors occurred
   */
  private void processOptions(final CommandLineBuilder cmdLine)
      throws MojoExecutionException {
<span class="nc" id="L793">    CommandLineOption opt = null;</span>
    // dest
<span class="nc" id="L795">    opt = cmdLine.createOpt();</span>
<span class="nc" id="L796">    opt.createArg().setValue(&quot;--dest&quot;);</span>
    try {
<span class="nc" id="L798">      opt.createArg().setValue(dest.getCanonicalPath());</span>
<span class="nc" id="L799">    } catch (IOException ex) {</span>
<span class="nc" id="L800">      throw new MojoExecutionException(MessageFormat.format(</span>
          ERROR_RESOLVE,
          &quot;--dest&quot;,
<span class="nc" id="L803">          dest.toString()), ex);</span>
<span class="nc" id="L804">    }</span>
    // temp
<span class="nc bnc" id="L806" title="All 2 branches missed.">    if (temp != null) {</span>
<span class="nc" id="L807">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L808">      opt.createArg().setValue(&quot;--temp&quot;);</span>
      try {
<span class="nc" id="L810">        opt.createArg().setValue(temp.getCanonicalPath());</span>
<span class="nc" id="L811">      } catch (IOException ex) {</span>
<span class="nc" id="L812">        throw new MojoExecutionException(MessageFormat.format(</span>
            ERROR_RESOLVE,
            &quot;--temp&quot;,
<span class="nc" id="L815">            temp.toString()), ex);</span>
<span class="nc" id="L816">      }</span>
    }
    // type
<span class="nc bnc" id="L819" title="All 4 branches missed.">    if (type != null &amp;&amp; !type.equals(PackageType.PLATFORM)) {</span>
<span class="nc" id="L820">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L821">      opt.createArg().setValue(&quot;--type&quot;);</span>
<span class="nc bnc" id="L822" title="All 8 branches missed.">      switch (type) {</span>
        case IMAGE:
<span class="nc" id="L824">          opt.createArg().setValue(&quot;app-image&quot;);</span>
<span class="nc" id="L825">          break;</span>
        case EXE:
<span class="nc" id="L827">          opt.createArg().setValue(&quot;exe&quot;);</span>
<span class="nc" id="L828">          break;</span>
        case MSI:
<span class="nc" id="L830">          opt.createArg().setValue(&quot;msi&quot;);</span>
<span class="nc" id="L831">          break;</span>
        case RPM:
<span class="nc" id="L833">          opt.createArg().setValue(&quot;rpm&quot;);</span>
<span class="nc" id="L834">          break;</span>
        case DEB:
<span class="nc" id="L836">          opt.createArg().setValue(&quot;deb&quot;);</span>
<span class="nc" id="L837">          break;</span>
        case PKG:
<span class="nc" id="L839">          opt.createArg().setValue(&quot;pkg&quot;);</span>
<span class="nc" id="L840">          break;</span>
        case DMG:
<span class="nc" id="L842">          opt.createArg().setValue(&quot;dmg&quot;);</span>
<span class="nc" id="L843">          break;</span>
        default:
          // skip
      }
    }
    // verbose
<span class="nc bnc" id="L849" title="All 2 branches missed.">    if (verbose) {</span>
<span class="nc" id="L850">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L851">      opt.createArg().setValue(&quot;--verbose&quot;);</span>
    }
    // appversion
<span class="nc bnc" id="L854" title="All 2 branches missed.">    if (!StringUtils.isBlank(appversion)) {</span>
<span class="nc" id="L855">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L856">      opt.createArg().setValue(&quot;--app-version&quot;);</span>
<span class="nc" id="L857">      opt.createArg().setValue(PluginUtils.wrapOpt(</span>
          appversion, WRAP_CHAR));
    }
    // copyright
<span class="nc bnc" id="L861" title="All 2 branches missed.">    if (!StringUtils.isBlank(copyright)) {</span>
<span class="nc" id="L862">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L863">      opt.createArg().setValue(&quot;--copyright&quot;);</span>
<span class="nc" id="L864">      opt.createArg().setValue(PluginUtils.wrapOpt(</span>
          copyright, WRAP_CHAR));
    }
    // description
<span class="nc bnc" id="L868" title="All 2 branches missed.">    if (!StringUtils.isBlank(description)) {</span>
<span class="nc" id="L869">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L870">      opt.createArg().setValue(&quot;--description&quot;);</span>
<span class="nc" id="L871">      opt.createArg().setValue(PluginUtils.wrapOpt(</span>
<span class="nc" id="L872">          description.replaceAll(SPACES_PATTERN, &quot; &quot;), WRAP_CHAR));</span>
    }
    // name
<span class="nc bnc" id="L875" title="All 2 branches missed.">    if (!StringUtils.isBlank(name)) {</span>
<span class="nc" id="L876">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L877">      opt.createArg().setValue(&quot;--name&quot;);</span>
<span class="nc" id="L878">      opt.createArg().setValue(PluginUtils.wrapOpt(</span>
          name, WRAP_CHAR));
    }
    // vendor
<span class="nc bnc" id="L882" title="All 2 branches missed.">    if (!StringUtils.isBlank(vendor)) {</span>
<span class="nc" id="L883">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L884">      opt.createArg().setValue(&quot;--vendor&quot;);</span>
<span class="nc" id="L885">      opt.createArg().setValue(PluginUtils.wrapOpt(</span>
          vendor, WRAP_CHAR));
    }
    // icon
<span class="nc bnc" id="L889" title="All 2 branches missed.">    if (icon != null) {</span>
<span class="nc" id="L890">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L891">      opt.createArg().setValue(&quot;--icon&quot;);</span>
      try {
<span class="nc" id="L893">        opt.createArg().setValue(icon.getCanonicalPath());</span>
<span class="nc" id="L894">      } catch (IOException ex) {</span>
<span class="nc" id="L895">        throw new MojoExecutionException(MessageFormat.format(</span>
            ERROR_RESOLVE,
            &quot;--icon&quot;,
<span class="nc" id="L898">            icon.toString()), ex);</span>
<span class="nc" id="L899">      }</span>
    }
    // input
<span class="nc bnc" id="L902" title="All 2 branches missed.">    if (input != null) {</span>
<span class="nc" id="L903">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L904">      opt.createArg().setValue(&quot;--input&quot;);</span>
      try {
<span class="nc" id="L906">        opt.createArg().setValue(input.getCanonicalPath());</span>
<span class="nc" id="L907">      } catch (IOException ex) {</span>
<span class="nc" id="L908">        throw new MojoExecutionException(MessageFormat.format(</span>
            ERROR_RESOLVE,
            &quot;--input&quot;,
<span class="nc" id="L911">            input.toString()), ex);</span>
<span class="nc" id="L912">      }</span>
    }
    // runtimeimage
<span class="nc bnc" id="L915" title="All 2 branches missed.">    if (runtimeimage != null) {</span>
<span class="nc" id="L916">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L917">      opt.createArg().setValue(&quot;--runtime-image&quot;);</span>
      try {
<span class="nc" id="L919">        opt.createArg().setValue(runtimeimage.getCanonicalPath());</span>
<span class="nc" id="L920">      } catch (IOException ex) {</span>
<span class="nc" id="L921">        throw new MojoExecutionException(MessageFormat.format(</span>
            ERROR_RESOLVE,
            &quot;--runtime-image&quot;,
<span class="nc" id="L924">            runtimeimage.toString()), ex);</span>
<span class="nc" id="L925">      }</span>
    }
    // module
<span class="nc bnc" id="L928" title="All 2 branches missed.">    if (!StringUtils.isBlank(module)) {</span>
<span class="nc" id="L929">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L930">      opt.createArg().setValue(&quot;--module&quot;);</span>
<span class="nc" id="L931">      opt.createArg().setValue(StringUtils.stripToEmpty(</span>
          module));
    }
    // mainjar
<span class="nc bnc" id="L935" title="All 2 branches missed.">    if (!StringUtils.isBlank(mainjar)) {</span>
<span class="nc" id="L936">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L937">      opt.createArg().setValue(&quot;--main-jar&quot;);</span>
<span class="nc" id="L938">      opt.createArg().setValue(PluginUtils.wrapOpt(</span>
          mainjar, WRAP_CHAR));
    }
    // mainclass
<span class="nc bnc" id="L942" title="All 2 branches missed.">    if (!StringUtils.isBlank(mainclass)) {</span>
<span class="nc" id="L943">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L944">      opt.createArg().setValue(&quot;--main-class&quot;);</span>
<span class="nc" id="L945">      opt.createArg().setValue(StringUtils.stripToEmpty(</span>
          mainclass));
    }
    // arguments
    // TODO: argument quotes
    /*
    --arguments &quot;\&quot;String 1\&quot; \&quot;String 2\&quot;&quot;
    --arguments &quot;\&quot;String 1\&quot;&quot; --arguments &quot;\&quot;String 2\&quot;&quot;
    --arguments &quot;'String 1'&quot; --arguments &quot;'String 2'&quot;
    */
<span class="nc bnc" id="L955" title="All 2 branches missed.">    if (!StringUtils.isBlank(arguments)) {</span>
<span class="nc" id="L956">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L957">      opt.createArg().setValue(&quot;--arguments&quot;);</span>
<span class="nc" id="L958">      opt.createArg().setValue(PluginUtils.wrapOpt(</span>
          arguments, WRAP_CHAR));
    }
    // javaoptions
    // TODO: javaoptions quotes
    /*
    --java-options &quot;\&quot;-DAppOption=text string\&quot;&quot;
    --java-options &quot;'-DAppOption=text string'&quot;
    --java-options &quot;-XX:OnError=\&quot;\\\&quot;userdump.exe %p\\\&quot;\&quot;&quot;
    --java-options &quot;-splash:\$APPDIR/myAppSplash.jpg&quot;
    */
<span class="nc bnc" id="L969" title="All 2 branches missed.">    if (!StringUtils.isBlank(javaoptions)) {</span>
<span class="nc" id="L970">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L971">      opt.createArg().setValue(&quot;--java-options&quot;);</span>
<span class="nc" id="L972">      opt.createArg().setValue(PluginUtils.wrapOpt(</span>
          javaoptions, WRAP_CHAR));
    }
    // addlaunchers
<span class="nc bnc" id="L976" title="All 4 branches missed.">    if (addlaunchers != null &amp;&amp; !addlaunchers.isEmpty()) {</span>
<span class="nc bnc" id="L977" title="All 2 branches missed.">      for (final Launcher addlauncher : addlaunchers) {</span>
<span class="nc" id="L978">        final String name = StringUtils.stripToEmpty(addlauncher.getName());</span>
<span class="nc bnc" id="L979" title="All 2 branches missed.">        if (!StringUtils.isBlank(name)) {</span>
<span class="nc" id="L980">          final File file = processLauncher(addlauncher);</span>
<span class="nc" id="L981">          tempFiles.add(file);</span>
<span class="nc" id="L982">          opt = cmdLine.createOpt();</span>
<span class="nc" id="L983">          opt.createArg().setValue(&quot;--add-launcher&quot;);</span>
          try {
<span class="nc" id="L985">            opt.createArg().setValue(name + &quot;=&quot; + file.getCanonicalPath());</span>
<span class="nc" id="L986">          } catch (IOException ex) {</span>
<span class="nc" id="L987">            throw new MojoExecutionException(MessageFormat.format(</span>
                ERROR_RESOLVE,
                &quot;--add-launcher&quot;,
<span class="nc" id="L990">                file.toString()), ex);</span>
<span class="nc" id="L991">          }</span>
        }
<span class="nc" id="L993">      }</span>
    }
    // winconsole
<span class="nc bnc" id="L996" title="All 2 branches missed.">    if (winconsole) {</span>
<span class="nc" id="L997">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L998">      opt.createArg().setValue(&quot;--win-console&quot;);</span>
    }
    // appimage
<span class="nc bnc" id="L1001" title="All 2 branches missed.">    if (appimage != null) {</span>
<span class="nc" id="L1002">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1003">      opt.createArg().setValue(&quot;--app-image&quot;);</span>
      try {
<span class="nc" id="L1005">        opt.createArg().setValue(appimage.getCanonicalPath());</span>
<span class="nc" id="L1006">      } catch (IOException ex) {</span>
<span class="nc" id="L1007">        throw new MojoExecutionException(MessageFormat.format(</span>
            ERROR_RESOLVE,
            &quot;--app-image&quot;,
<span class="nc" id="L1010">            appimage.toString()), ex);</span>
<span class="nc" id="L1011">      }</span>
    }
    // fileassociations
<span class="nc bnc" id="L1014" title="All 2 branches missed.">    if (fileassociations != null) {</span>
<span class="nc bnc" id="L1015" title="All 2 branches missed.">      for (final File fileassociation : fileassociations) {</span>
<span class="nc bnc" id="L1016" title="All 2 branches missed.">        if (fileassociation != null</span>
<span class="nc bnc" id="L1017" title="All 2 branches missed.">            &amp;&amp; !StringUtils.isBlank(fileassociation.toString())) {</span>
<span class="nc" id="L1018">          opt = cmdLine.createOpt();</span>
<span class="nc" id="L1019">          opt.createArg().setValue(&quot;--file-associations&quot;);</span>
          try {
<span class="nc" id="L1021">            opt.createArg().setValue(fileassociation.getCanonicalPath());</span>
<span class="nc" id="L1022">          } catch (IOException ex) {</span>
<span class="nc" id="L1023">            throw new MojoExecutionException(MessageFormat.format(</span>
                ERROR_RESOLVE,
                &quot;--file-associations&quot;,
<span class="nc" id="L1026">                fileassociation.toString()), ex);</span>
<span class="nc" id="L1027">          }</span>
        }
<span class="nc" id="L1029">      }</span>
    }
    // installdir
<span class="nc bnc" id="L1032" title="All 2 branches missed.">    if (!StringUtils.isBlank(installdir)) {</span>
<span class="nc" id="L1033">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1034">      opt.createArg().setValue(&quot;--install-dir&quot;);</span>
<span class="nc" id="L1035">      opt.createArg().setValue(PluginUtils.wrapOpt(</span>
          installdir, WRAP_CHAR));
    }
    // licensefile
<span class="nc bnc" id="L1039" title="All 2 branches missed.">    if (licensefile != null) {</span>
<span class="nc" id="L1040">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1041">      opt.createArg().setValue(&quot;--license-file&quot;);</span>
      try {
<span class="nc" id="L1043">        opt.createArg().setValue(licensefile.getCanonicalPath());</span>
<span class="nc" id="L1044">      } catch (IOException ex) {</span>
<span class="nc" id="L1045">        throw new MojoExecutionException(MessageFormat.format(</span>
            ERROR_RESOLVE,
            &quot;--license-file&quot;,
<span class="nc" id="L1048">            licensefile.toString()), ex);</span>
<span class="nc" id="L1049">      }</span>
    }
    // resourcedir
<span class="nc bnc" id="L1052" title="All 2 branches missed.">    if (resourcedir != null) {</span>
<span class="nc" id="L1053">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1054">      opt.createArg().setValue(&quot;--resource-dir&quot;);</span>
      try {
<span class="nc" id="L1056">        opt.createArg().setValue(resourcedir.getCanonicalPath());</span>
<span class="nc" id="L1057">      } catch (IOException ex) {</span>
<span class="nc" id="L1058">        throw new MojoExecutionException(MessageFormat.format(</span>
            ERROR_RESOLVE,
            &quot;--resource-dir&quot;,
<span class="nc" id="L1061">            resourcedir.toString()), ex);</span>
<span class="nc" id="L1062">      }</span>
    }
    // windirchooser
<span class="nc bnc" id="L1065" title="All 2 branches missed.">    if (windirchooser) {</span>
<span class="nc" id="L1066">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1067">      opt.createArg().setValue(&quot;--win-dir-chooser&quot;);</span>
    }
    // winmenu
<span class="nc bnc" id="L1070" title="All 2 branches missed.">    if (winmenu) {</span>
<span class="nc" id="L1071">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1072">      opt.createArg().setValue(&quot;--win-menu&quot;);</span>
    }
    // winmenugroup
<span class="nc bnc" id="L1075" title="All 2 branches missed.">    if (!StringUtils.isBlank(winmenugroup)) {</span>
<span class="nc" id="L1076">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1077">      opt.createArg().setValue(&quot;--win-menu-group&quot;);</span>
<span class="nc" id="L1078">      opt.createArg().setValue(PluginUtils.wrapOpt(</span>
          winmenugroup, WRAP_CHAR));
    }
    // winperuserinstall
<span class="nc bnc" id="L1082" title="All 2 branches missed.">    if (winperuserinstall) {</span>
<span class="nc" id="L1083">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1084">      opt.createArg().setValue(&quot;--win-per-user-install&quot;);</span>
    }
    // winshortcut
<span class="nc bnc" id="L1087" title="All 2 branches missed.">    if (winshortcut) {</span>
<span class="nc" id="L1088">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1089">      opt.createArg().setValue(&quot;--win-shortcut&quot;);</span>
    }
    // winupgradeuuid
<span class="nc bnc" id="L1092" title="All 2 branches missed.">    if (!StringUtils.isBlank(winupgradeuuid)) {</span>
<span class="nc" id="L1093">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1094">      opt.createArg().setValue(&quot;--win-upgrade-uuid&quot;);</span>
<span class="nc" id="L1095">      opt.createArg().setValue(PluginUtils.wrapOpt(</span>
          winupgradeuuid, WRAP_CHAR));
    }
    // macpackageidentifier
<span class="nc bnc" id="L1099" title="All 2 branches missed.">    if (!StringUtils.isBlank(macpackageidentifier)) {</span>
<span class="nc" id="L1100">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1101">      opt.createArg().setValue(&quot;--mac-package-identifier&quot;);</span>
<span class="nc" id="L1102">      opt.createArg().setValue(PluginUtils.wrapOpt(</span>
          macpackageidentifier, WRAP_CHAR));
    }
    // macpackagename
<span class="nc bnc" id="L1106" title="All 2 branches missed.">    if (!StringUtils.isBlank(macpackagename)) {</span>
<span class="nc" id="L1107">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1108">      opt.createArg().setValue(&quot;--mac-package-name&quot;);</span>
<span class="nc" id="L1109">      opt.createArg().setValue(PluginUtils.wrapOpt(</span>
          macpackagename, WRAP_CHAR));
    }
    // macpackagesigningprefix
<span class="nc bnc" id="L1113" title="All 2 branches missed.">    if (!StringUtils.isBlank(macpackagesigningprefix)) {</span>
<span class="nc" id="L1114">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1115">      opt.createArg().setValue(&quot;--mac-package-signing-prefix&quot;);</span>
<span class="nc" id="L1116">      opt.createArg().setValue(PluginUtils.wrapOpt(</span>
          macpackagesigningprefix, WRAP_CHAR));
    }
    // macsign
<span class="nc bnc" id="L1120" title="All 2 branches missed.">    if (macsign) {</span>
<span class="nc" id="L1121">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1122">      opt.createArg().setValue(&quot;--mac-sign&quot;);</span>
    }
    // macsigningkeychain
<span class="nc bnc" id="L1125" title="All 2 branches missed.">    if (macsigningkeychain != null) {</span>
<span class="nc" id="L1126">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1127">      opt.createArg().setValue(&quot;--mac-signing-keychain&quot;);</span>
      try {
<span class="nc" id="L1129">        opt.createArg().setValue(macsigningkeychain.getCanonicalPath());</span>
<span class="nc" id="L1130">      } catch (IOException ex) {</span>
<span class="nc" id="L1131">        throw new MojoExecutionException(MessageFormat.format(</span>
            ERROR_RESOLVE,
            &quot;--mac-signing-keychain&quot;,
<span class="nc" id="L1134">            macsigningkeychain.toString()), ex);</span>
<span class="nc" id="L1135">      }</span>
    }
    // macsigningkeyusername
<span class="nc bnc" id="L1138" title="All 2 branches missed.">    if (!StringUtils.isBlank(macsigningkeyusername)) {</span>
<span class="nc" id="L1139">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1140">      opt.createArg().setValue(&quot;--mac-signing-key-user-name&quot;);</span>
<span class="nc" id="L1141">      opt.createArg().setValue(PluginUtils.wrapOpt(</span>
          macsigningkeyusername, WRAP_CHAR));
    }
    // linuxpackagename
<span class="nc bnc" id="L1145" title="All 2 branches missed.">    if (!StringUtils.isBlank(linuxpackagename)) {</span>
<span class="nc" id="L1146">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1147">      opt.createArg().setValue(&quot;--linux-package-name&quot;);</span>
<span class="nc" id="L1148">      opt.createArg().setValue(PluginUtils.wrapOpt(</span>
          linuxpackagename, WRAP_CHAR));
    }
    // linuxdebmaintainer
<span class="nc bnc" id="L1152" title="All 2 branches missed.">    if (!StringUtils.isBlank(linuxdebmaintainer)) {</span>
<span class="nc" id="L1153">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1154">      opt.createArg().setValue(&quot;--linux-deb-maintainer&quot;);</span>
<span class="nc" id="L1155">      opt.createArg().setValue(PluginUtils.wrapOpt(</span>
          linuxdebmaintainer, WRAP_CHAR));
    }
    // linuxmenugroup
<span class="nc bnc" id="L1159" title="All 2 branches missed.">    if (!StringUtils.isBlank(linuxmenugroup)) {</span>
<span class="nc" id="L1160">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1161">      opt.createArg().setValue(&quot;--linux-menu-group&quot;);</span>
<span class="nc" id="L1162">      opt.createArg().setValue(PluginUtils.wrapOpt(</span>
          linuxmenugroup, WRAP_CHAR));
    }
    // linuxpackagedeps
<span class="nc bnc" id="L1166" title="All 2 branches missed.">    if (linuxpackagedeps) {</span>
<span class="nc" id="L1167">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1168">      opt.createArg().setValue(&quot;--linux-package-deps&quot;);</span>
    }
    // linuxrpmlicensetype
<span class="nc bnc" id="L1171" title="All 2 branches missed.">    if (!StringUtils.isBlank(linuxrpmlicensetype)) {</span>
<span class="nc" id="L1172">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1173">      opt.createArg().setValue(&quot;--linux-rpm-license-type&quot;);</span>
<span class="nc" id="L1174">      opt.createArg().setValue(PluginUtils.wrapOpt(</span>
          linuxrpmlicensetype, WRAP_CHAR));
    }
    // linuxapprelease
<span class="nc bnc" id="L1178" title="All 2 branches missed.">    if (!StringUtils.isBlank(linuxapprelease)) {</span>
<span class="nc" id="L1179">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1180">      opt.createArg().setValue(&quot;--linux-app-release&quot;);</span>
<span class="nc" id="L1181">      opt.createArg().setValue(PluginUtils.wrapOpt(</span>
          linuxapprelease, WRAP_CHAR));
    }
    // linuxappcategory
<span class="nc bnc" id="L1185" title="All 2 branches missed.">    if (!StringUtils.isBlank(linuxappcategory)) {</span>
<span class="nc" id="L1186">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1187">      opt.createArg().setValue(&quot;--linux-app-category&quot;);</span>
<span class="nc" id="L1188">      opt.createArg().setValue(PluginUtils.wrapOpt(</span>
          linuxappcategory, WRAP_CHAR));
    }
    // linuxshortcut
<span class="nc bnc" id="L1192" title="All 2 branches missed.">    if (linuxshortcut) {</span>
<span class="nc" id="L1193">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1194">      opt.createArg().setValue(&quot;--linux-shortcut&quot;);</span>
    }
<span class="nc" id="L1196">  }</span>

  /**
   * Process additional launcher.
   * Create a temporary file contains the efective launcher properties.
   *
   * @param launcher the additional launcher
   *
   * @return the temporary file contains the efective launcher properties
   *
   * @throws MojoExecutionException if any errors occurred
   */
  private File processLauncher(final Launcher launcher)
      throws MojoExecutionException {
<span class="nc" id="L1210">    final String name = launcher.getName();</span>
    // get properties
    Properties props;
    try {
<span class="nc" id="L1214">      props = launcher.getProperties(getCharset());</span>
<span class="nc" id="L1215">    } catch (IOException ex) {</span>
<span class="nc" id="L1216">      throw new MojoExecutionException(MessageFormat.format(</span>
          &quot;Error: Unable to read properties for launcher: [{0}]&quot;,
          name), ex);
<span class="nc" id="L1219">    }</span>
    // create a temporary properties file
    File file;
    try {
<span class="nc" id="L1223">      file = Files.createTempFile(getBuildDir().toPath(),</span>
<span class="nc" id="L1224">          PROPS_PREFIX, PROPS_SUFFIX).toFile();</span>
<span class="nc" id="L1225">    } catch (IOException ex) {</span>
<span class="nc" id="L1226">      throw new MojoExecutionException(MessageFormat.format(</span>
          &quot;Error: Unable to create temporary file for launcher: [{0}]&quot;,
          name), ex);
<span class="nc" id="L1229">    }</span>
    // save properties to the temporary file
<span class="nc" id="L1231">    try (BufferedWriter bw =</span>
<span class="nc" id="L1232">        Files.newBufferedWriter(file.toPath(), getCharset())) {</span>
<span class="nc" id="L1233">      props.store(bw, null);</span>
<span class="nc" id="L1234">    } catch (IOException ex) {</span>
<span class="nc" id="L1235">      throw new MojoExecutionException(MessageFormat.format(</span>
          &quot;Error: Unable to write temporary file for launcher: [{0}]&quot;,
          name), ex);
<span class="nc" id="L1238">    }</span>
<span class="nc bnc" id="L1239" title="All 2 branches missed.">    if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L1240">      getLog().debug(MessageFormat.format(</span>
          &quot;Found additional launcher: [{0}]&quot;, name)
<span class="nc" id="L1242">          + System.lineSeparator()</span>
<span class="nc" id="L1243">          + props.toString());</span>
    }
<span class="nc" id="L1245">    return file;</span>
  }

  /**
   * Resolve project dependencies.
   *
   * @return map of the resolved project dependencies
   *
   * @throws MojoExecutionException if any errors occurred while resolving
   *                                dependencies
   */
  private ResolvePathsResult&lt;File&gt; resolveDependencies()
      throws MojoExecutionException {

    // get project artifacts - all dependencies that this project has,
    // including transitive ones (depends on what phases have run)
<span class="nc" id="L1261">    final Set&lt;Artifact&gt; artifacts = getProject().getArtifacts();</span>
<span class="nc bnc" id="L1262" title="All 2 branches missed.">    if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L1263">      getLog().debug(PluginUtils.getArtifactSetDebugInfo(artifacts));</span>
    }

    // create a list of the paths which will be resolved
<span class="nc" id="L1267">    final List&lt;File&gt; paths = new ArrayList&lt;&gt;();</span>

    // add the project output directory
<span class="nc" id="L1270">    paths.add(getOutputDir());</span>

    // SCOPE_COMPILE  - This is the default scope, used if none is specified.
    //                  Compile dependencies are available in all classpaths.
    //                  Furthermore, those dependencies are propagated to
    //                  dependent projects.
    // SCOPE_PROVIDED - This is much like compile, but indicates you expect
    //                  the JDK or a container to provide it at runtime.
    //                  It is only available on the compilation and
    //                  test classpath, and is not transitive.
    // SCOPE_SYSTEM   - This scope is similar to provided except that you
    //                  have to provide the JAR which contains it explicitly.
    //                  The artifact is always available and is not looked up
    //                  in a repository.    
    // SCOPE_RUNTIME  - This scope indicates that the dependency is not
    //                  required for compilation, but is for execution.
    //                  It is in the runtime and test classpaths, but not
    //                  the compile classpath.
    // SCOPE_TEST     - This scope indicates that the dependency is not
    //                  required for normal use of the application, and is
    //                  only available for the test compilation and execution
    //                  phases. It is not transitive.
    // SCOPE_IMPORT   - This scope indicates that the dependency is a managed
    //                  POM dependency i.e. only other POM into
    //                  the dependencyManagement section.

    // [ !SCOPE_TEST ] add the project artifacts files
<span class="nc" id="L1297">    paths.addAll(artifacts.stream()</span>
<span class="nc bnc" id="L1298" title="All 4 branches missed.">        .filter(a -&gt; a != null &amp;&amp; !Artifact.SCOPE_TEST.equals(a.getScope()))</span>
<span class="nc" id="L1299">        .map(a -&gt; a.getFile())</span>
<span class="nc" id="L1300">        .collect(Collectors.toList()));</span>

    // [ SCOPE_SYSTEM ] add the project system dependencies
    // getSystemPath() is used only if the dependency scope is system
<span class="nc" id="L1304">    paths.addAll(getProject().getDependencies().stream()</span>
<span class="nc bnc" id="L1305" title="All 4 branches missed.">        .filter(d -&gt; d != null &amp;&amp; !StringUtils.isBlank(d.getSystemPath()))</span>
<span class="nc" id="L1306">        .map(d -&gt; new File(StringUtils.stripToEmpty(d.getSystemPath())))</span>
<span class="nc" id="L1307">        .collect(Collectors.toList()));</span>

    // create request contains all information
    // required to analyze the project
<span class="nc" id="L1311">    final ResolvePathsRequest&lt;File&gt; request =</span>
<span class="nc" id="L1312">        ResolvePathsRequest.ofFiles(paths);</span>

    // this is used to resolve main module descriptor
<span class="nc" id="L1315">    final File descriptorFile =</span>
<span class="nc" id="L1316">        getOutputDir().toPath().resolve(DESCRIPTOR_NAME).toFile();</span>
<span class="nc bnc" id="L1317" title="All 4 branches missed.">    if (descriptorFile.exists() &amp;&amp; !descriptorFile.isDirectory()) {</span>
<span class="nc" id="L1318">      request.setMainModuleDescriptor(descriptorFile);</span>
    }

    // this is used to extract the module name
<span class="nc bnc" id="L1322" title="All 2 branches missed.">    if (getToolHomeDirectory() != null) {</span>
<span class="nc" id="L1323">      request.setJdkHome(getToolHomeDirectory());</span>
    }

    // resolve project dependencies
    try {
<span class="nc" id="L1328">      return locationManager.resolvePaths(request);</span>
<span class="nc" id="L1329">    } catch (IOException ex) {</span>
<span class="nc" id="L1330">      throw new MojoExecutionException(</span>
          &quot;Error: Unable to resolve project dependencies&quot;, ex);
    }

  }

  /**
   * Fetch the resolved main module descriptor.
   *
   * @return main module descriptor or null if it not exists
   */
  private JavaModuleDescriptor fetchMainModuleDescriptor() {
<span class="nc" id="L1342">    final JavaModuleDescriptor descriptor =</span>
<span class="nc" id="L1343">        projectDependencies.getMainModuleDescriptor();</span>
<span class="nc bnc" id="L1344" title="All 2 branches missed.">    if (descriptor == null) {</span>
      // detected that the project is non modular
<span class="nc bnc" id="L1346" title="All 2 branches missed.">      if (getLog().isWarnEnabled()) {</span>
<span class="nc" id="L1347">        getLog().warn(&quot;The main module descriptor not found&quot;);</span>
      }
    } else {
<span class="nc bnc" id="L1350" title="All 2 branches missed.">      if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L1351">        getLog().debug(MessageFormat.format(</span>
<span class="nc" id="L1352">            &quot;Found the main module descriptor: [{0}]&quot;, descriptor.name()));</span>
      }
    }
<span class="nc" id="L1355">    return descriptor;</span>
  }

  /**
   * Fetch path exceptions for every modulename which resolution failed.
   *
   * @return pairs of path exception file and cause
   */
  private Map&lt;File, String&gt; fetchPathExceptions() {
<span class="nc" id="L1364">    return projectDependencies.getPathExceptions()</span>
<span class="nc" id="L1365">        .entrySet().stream()</span>
<span class="nc bnc" id="L1366" title="All 4 branches missed.">        .filter(entry -&gt; entry != null &amp;&amp; entry.getKey() != null)</span>
<span class="nc" id="L1367">        .collect(Collectors.toMap(</span>
<span class="nc" id="L1368">            entry -&gt; entry.getKey(),</span>
<span class="nc" id="L1369">            entry -&gt; PluginUtils.getThrowableCause(entry.getValue())</span>
        ));
  }

  /**
   * Fetch classpath elements.
   *
   * @return classpath elements
   */
  private List&lt;File&gt; fetchClasspathElements() {
<span class="nc" id="L1379">    final List&lt;File&gt; result = projectDependencies.getClasspathElements()</span>
<span class="nc" id="L1380">        .stream()</span>
<span class="nc" id="L1381">        .filter(Objects::nonNull)</span>
<span class="nc" id="L1382">        .collect(Collectors.toList());</span>
<span class="nc bnc" id="L1383" title="All 2 branches missed.">    if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L1384">      getLog().debug(&quot;Found classpath elements: &quot; + result.size()</span>
<span class="nc" id="L1385">          + System.lineSeparator()</span>
<span class="nc" id="L1386">          + result.stream()</span>
<span class="nc" id="L1387">              .map(file -&gt; file.toString())</span>
<span class="nc" id="L1388">              .collect(Collectors.joining(System.lineSeparator())));</span>
    }
<span class="nc" id="L1390">    return result;</span>
  }

  /**
   * Fetch modulepath elements.
   *
   * @return modulepath elements
   */
  private List&lt;File&gt; fetchModulepathElements() {
<span class="nc" id="L1399">    final List&lt;File&gt; result = projectDependencies.getModulepathElements()</span>
<span class="nc" id="L1400">        .keySet()</span>
<span class="nc" id="L1401">        .stream()</span>
<span class="nc" id="L1402">        .filter(Objects::nonNull)</span>
<span class="nc" id="L1403">        .collect(Collectors.toList());</span>
<span class="nc bnc" id="L1404" title="All 2 branches missed.">    if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L1405">      getLog().debug(&quot;Found modulepath elements: &quot; + result.size()</span>
<span class="nc" id="L1406">          + System.lineSeparator()</span>
<span class="nc" id="L1407">          + projectDependencies.getModulepathElements().entrySet().stream()</span>
<span class="nc bnc" id="L1408" title="All 4 branches missed.">              .filter(entry -&gt; entry != null &amp;&amp; entry.getKey() != null)</span>
<span class="nc" id="L1409">              .map(entry -&gt; entry.getKey().toString()</span>
<span class="nc bnc" id="L1410" title="All 2 branches missed.">                  + (ModuleNameSource.FILENAME.equals(entry.getValue())</span>
<span class="nc" id="L1411">                      ? System.lineSeparator()</span>
                          + &quot;[!] Detected 'requires' filename based &quot;
                          + &quot;automatic module&quot;
<span class="nc" id="L1414">                          + System.lineSeparator()</span>
                          + &quot;[!] Please don't publish this project to &quot;
                          + &quot;a public artifact repository&quot;
<span class="nc" id="L1417">                          + System.lineSeparator()</span>
                          + (mainModuleDescriptor != null
<span class="nc bnc" id="L1419" title="All 4 branches missed.">                              &amp;&amp; mainModuleDescriptor.exports().isEmpty()</span>
<span class="nc" id="L1420">                                  ? &quot;[!] APPLICATION&quot;</span>
<span class="nc" id="L1421">                                  : &quot;[!] LIBRARY&quot;)</span>
<span class="nc" id="L1422">                      : &quot;&quot;))</span>
<span class="nc" id="L1423">              .collect(Collectors.joining(System.lineSeparator())));</span>
    }
<span class="nc" id="L1425">    return result;</span>
  }

  /**
   * Get path from the pathelements parameter.
   *
   * @return path contains parameter elements
   */
  private String getPathElements() {
<span class="nc" id="L1434">    String result = null;</span>
<span class="nc bnc" id="L1435" title="All 2 branches missed.">    if (modulepath != null) {</span>
<span class="nc" id="L1436">      final List&lt;File&gt; pathelements = modulepath.getPathElements();</span>
<span class="nc bnc" id="L1437" title="All 4 branches missed.">      if (pathelements != null &amp;&amp; !pathelements.isEmpty()) {</span>
<span class="nc" id="L1438">        result = pathelements.stream()</span>
<span class="nc" id="L1439">            .filter(Objects::nonNull)</span>
<span class="nc" id="L1440">            .map(file -&gt; file.toString())</span>
<span class="nc" id="L1441">            .collect(Collectors.joining(File.pathSeparator));</span>
<span class="nc bnc" id="L1442" title="All 2 branches missed.">        if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L1443">          getLog().debug(PluginUtils.getPathElementsDebugInfo(&quot;PATHELEMENTS&quot;,</span>
              pathelements));
<span class="nc" id="L1445">          getLog().debug(result);</span>
        }
      }
    }
<span class="nc" id="L1449">    return result;</span>
  }

  /**
   * Get filesets from modulepath parameter.
   *
   * @return path contains filesets
   *
   * @throws MojoExecutionException if any errors occurred while resolving
   *                                a fileset
   */
  private String getFileSets() throws MojoExecutionException {
<span class="nc" id="L1461">    String result = null;</span>
<span class="nc bnc" id="L1462" title="All 2 branches missed.">    if (modulepath != null) {</span>
<span class="nc" id="L1463">      final List&lt;FileSet&gt; filesets = modulepath.getFileSets();</span>
<span class="nc bnc" id="L1464" title="All 4 branches missed.">      if (filesets != null &amp;&amp; !filesets.isEmpty()) {</span>
<span class="nc bnc" id="L1465" title="All 2 branches missed.">        for (final FileSet fileSet : filesets) {</span>
          final File fileSetDir;
          try {
<span class="nc" id="L1468">            fileSetDir =</span>
<span class="nc" id="L1469">                PluginUtils.normalizeFileSetBaseDir(getBaseDir(), fileSet);</span>
<span class="nc" id="L1470">          } catch (IOException ex) {</span>
<span class="nc" id="L1471">            throw new MojoExecutionException(</span>
                &quot;Error: Unable to resolve fileset&quot;, ex);
<span class="nc" id="L1473">          }</span>
<span class="nc" id="L1474">          result = Stream.of(getFileSetManager().getIncludedFiles(fileSet))</span>
<span class="nc bnc" id="L1475" title="All 2 branches missed.">              .filter(fileName -&gt; !StringUtils.isBlank(fileName))</span>
<span class="nc" id="L1476">              .map(fileName -&gt; fileSetDir.toPath().resolve(</span>
<span class="nc" id="L1477">                  StringUtils.stripToEmpty(fileName)).toString())</span>
<span class="nc" id="L1478">              .collect(Collectors.joining(File.pathSeparator));</span>
<span class="nc bnc" id="L1479" title="All 2 branches missed.">          if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L1480">            getLog().debug(PluginUtils.getFileSetDebugInfo(&quot;FILESET&quot;,</span>
                fileSet, result));
          }
<span class="nc" id="L1483">        }</span>
      }
    }
<span class="nc" id="L1486">    return result;</span>
  }

  /**
   * Get dirsets from modulepath parameter.
   *
   * @return path contains dirsets
   *
   * @throws MojoExecutionException if any errors occurred while resolving
   *                                a dirset
   */
  private String getDirSets() throws MojoExecutionException {
<span class="nc" id="L1498">    String result = null;</span>
<span class="nc bnc" id="L1499" title="All 2 branches missed.">    if (modulepath != null) {</span>
<span class="nc" id="L1500">      final List&lt;FileSet&gt; dirsets = modulepath.getDirSets();</span>
<span class="nc bnc" id="L1501" title="All 4 branches missed.">      if (dirsets != null &amp;&amp; !dirsets.isEmpty()) {</span>
<span class="nc bnc" id="L1502" title="All 2 branches missed.">        for (final FileSet dirSet : dirsets) {</span>
          final File dirSetDir;
          try {
<span class="nc" id="L1505">            dirSetDir =</span>
<span class="nc" id="L1506">                PluginUtils.normalizeFileSetBaseDir(getBaseDir(), dirSet);</span>
<span class="nc" id="L1507">          } catch (IOException ex) {</span>
<span class="nc" id="L1508">            throw new MojoExecutionException(</span>
                &quot;Error: Unable to resolve dirset&quot;, ex);
<span class="nc" id="L1510">          }</span>
<span class="nc" id="L1511">          result = Stream.of(getFileSetManager().getIncludedDirectories(dirSet))</span>
<span class="nc bnc" id="L1512" title="All 2 branches missed.">              .filter(dirName -&gt; !StringUtils.isBlank(dirName))</span>
<span class="nc" id="L1513">              .map(dirName -&gt; dirSetDir.toPath().resolve(</span>
<span class="nc" id="L1514">                  StringUtils.stripToEmpty(dirName)).toString())</span>
<span class="nc" id="L1515">              .collect(Collectors.joining(File.pathSeparator));</span>
<span class="nc bnc" id="L1516" title="All 2 branches missed.">          if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L1517">            getLog().debug(PluginUtils.getFileSetDebugInfo(&quot;DIRSET&quot;,</span>
                dirSet, result));
          }
<span class="nc" id="L1520">        }</span>
      }
    }
<span class="nc" id="L1523">    return result;</span>
  }

  /**
   * Get dependencysets from modulepath parameter.
   *
   * @return path contains dependencysets
   */
  private String getDependencySets() {
<span class="nc" id="L1532">    String result = null;</span>
<span class="nc bnc" id="L1533" title="All 2 branches missed.">    if (modulepath != null) {</span>
<span class="nc" id="L1534">      final List&lt;DependencySet&gt; dependencysets =</span>
<span class="nc" id="L1535">          modulepath.getDependencySets();</span>
<span class="nc bnc" id="L1536" title="All 4 branches missed.">      if (dependencysets != null &amp;&amp; !dependencysets.isEmpty()) {</span>
<span class="nc bnc" id="L1537" title="All 2 branches missed.">        for (final DependencySet dependencySet : dependencysets) {</span>
<span class="nc" id="L1538">          result = getIncludedDependencies(dependencySet)</span>
<span class="nc" id="L1539">              .stream()</span>
<span class="nc" id="L1540">              .collect(Collectors.joining(File.pathSeparator));</span>
<span class="nc bnc" id="L1541" title="All 2 branches missed.">          if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L1542">            getLog().debug(PluginUtils.getDependencySetDebugInfo(</span>
                &quot;DEPENDENCYSET&quot;, dependencySet, result));
          }
<span class="nc" id="L1545">        }</span>
      }
    }
<span class="nc" id="L1548">    return result;</span>
  }

  /**
   * Get the included project dependencies
   * defined in the specified dependencyset.
   *
   * @param depSet the dependencyset
   *
   * @return the set of the included project dependencies
   */
  private Set&lt;String&gt; getIncludedDependencies(final DependencySet depSet) {
<span class="nc" id="L1560">    return projectDependencies.getPathElements().entrySet().stream()</span>
<span class="nc bnc" id="L1561" title="All 2 branches missed.">        .filter(entry -&gt; entry != null</span>
<span class="nc bnc" id="L1562" title="All 2 branches missed.">            &amp;&amp; entry.getKey() != null</span>
<span class="nc bnc" id="L1563" title="All 2 branches missed.">            &amp;&amp; filterDependency(depSet, entry.getKey(), entry.getValue()))</span>
<span class="nc" id="L1564">        .map(entry -&gt; entry.getKey().toString())</span>
<span class="nc" id="L1565">        .collect(Collectors.toSet());</span>
  }

  /**
   * Get the excluded project dependencies
   * defined in the specified dependencyset.
   *
   * @param depSet the dependencyset
   *
   * @return the set of the excluded project dependencies
   */
  private Set&lt;String&gt; getExcludedDependencies(final DependencySet depSet) {
<span class="nc" id="L1577">    return projectDependencies.getPathElements().entrySet().stream()</span>
<span class="nc bnc" id="L1578" title="All 2 branches missed.">        .filter(entry -&gt; entry != null</span>
<span class="nc bnc" id="L1579" title="All 2 branches missed.">            &amp;&amp; entry.getKey() != null</span>
<span class="nc bnc" id="L1580" title="All 2 branches missed.">            &amp;&amp; !filterDependency(depSet, entry.getKey(), entry.getValue()))</span>
<span class="nc" id="L1581">        .map(entry -&gt; entry.getKey().toString())</span>
<span class="nc" id="L1582">        .collect(Collectors.toSet());</span>
  }

  /**
   * Checks whether the dependency defined by the file and
   * the module descriptor matches the rules defined in the dependencyset.
   * The dependency that matches at least one include pattern will be included,
   * but if the dependency matches at least one exclude pattern too,
   * then the dependency will not be included.
   *
   * @param depSet the dependencyset
   * @param file the dependency file
   * @param descriptor the dependency module descriptor
   *
   * @return will the dependency be accepted
   */
  private boolean filterDependency(final DependencySet depSet, final File file,
      final JavaModuleDescriptor descriptor) {

<span class="nc bnc" id="L1601" title="All 2 branches missed.">    if (descriptor == null) {</span>
<span class="nc bnc" id="L1602" title="All 2 branches missed.">      if (getLog().isWarnEnabled()) {</span>
<span class="nc" id="L1603">        getLog().warn(&quot;Missing module descriptor: &quot; + file);</span>
      }
    } else {
<span class="nc bnc" id="L1606" title="All 4 branches missed.">      if (descriptor.isAutomatic() &amp;&amp; getLog().isDebugEnabled()) {</span>
<span class="nc" id="L1607">        getLog().debug(&quot;Found automatic module: &quot; + file);</span>
      }
    }

<span class="nc" id="L1611">    boolean isIncluded = false;</span>

<span class="nc bnc" id="L1613" title="All 2 branches missed.">    if (depSet == null) {</span>
      // include module by default
<span class="nc" id="L1615">      isIncluded = true;</span>
      // include automatic module by default
<span class="nc bnc" id="L1617" title="All 4 branches missed.">      if (descriptor != null &amp;&amp; descriptor.isAutomatic()</span>
<span class="nc bnc" id="L1618" title="All 2 branches missed.">          &amp;&amp; getLog().isDebugEnabled()) {</span>
<span class="nc" id="L1619">        getLog().debug(&quot;Included automatic module: &quot; + file);</span>
      }
      // exclude output module by default
<span class="nc bnc" id="L1622" title="All 2 branches missed.">      if (file.compareTo(getOutputDir()) == 0) {</span>
<span class="nc" id="L1623">        isIncluded = false;</span>
<span class="nc bnc" id="L1624" title="All 2 branches missed.">        if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L1625">          getLog().debug(&quot;Excluded output module: &quot; + file);</span>
        }
      }
    } else {
<span class="nc bnc" id="L1629" title="All 4 branches missed.">      if (descriptor != null &amp;&amp; descriptor.isAutomatic()</span>
<span class="nc bnc" id="L1630" title="All 2 branches missed.">          &amp;&amp; depSet.isAutomaticExcluded()) {</span>
<span class="nc bnc" id="L1631" title="All 2 branches missed.">        if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L1632">          getLog().debug(&quot;Excluded automatic module: &quot; + file);</span>
        }
      } else {
<span class="nc bnc" id="L1635" title="All 2 branches missed.">        if (file.compareTo(getOutputDir()) == 0) {</span>
<span class="nc bnc" id="L1636" title="All 2 branches missed.">          if (depSet.isOutputIncluded()) {</span>
<span class="nc" id="L1637">            isIncluded = true;</span>
<span class="nc bnc" id="L1638" title="All 2 branches missed.">            if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L1639">              getLog().debug(&quot;Included output module: &quot; + file);</span>
            }
          } else {
<span class="nc bnc" id="L1642" title="All 2 branches missed.">            if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L1643">              getLog().debug(&quot;Excluded output module: &quot; + file);</span>
            }
          }
        } else {
<span class="nc bnc" id="L1647" title="All 2 branches missed.">          isIncluded = matchesIncludes(depSet, file, descriptor)</span>
<span class="nc bnc" id="L1648" title="All 2 branches missed.">              &amp;&amp; !matchesExcludes(depSet, file, descriptor);</span>
        }
      }
    }

<span class="nc bnc" id="L1653" title="All 2 branches missed.">    if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L1654">      getLog().debug(PluginUtils.getDependencyDebugInfo(file, descriptor,</span>
          isIncluded));
    }

<span class="nc" id="L1658">    return isIncluded;</span>
  }

  /**
   * Checks whether the dependency defined by the file and
   * the module descriptor matches the include patterns
   * from the dependencyset.
   *
   * @param depSet the dependencyset
   * @param file the file
   * @param descriptor the module descriptor
   *
   * @return should the dependency be included
   */
  private boolean matchesIncludes(final DependencySet depSet, final File file,
      final JavaModuleDescriptor descriptor) {

<span class="nc bnc" id="L1675" title="All 2 branches missed.">    final String name = descriptor == null ? &quot;&quot; : descriptor.name();</span>

<span class="nc" id="L1677">    final List&lt;String&gt; includes = depSet.getIncludes();</span>
<span class="nc" id="L1678">    final List&lt;String&gt; includenames = depSet.getIncludeNames();</span>

<span class="nc" id="L1680">    boolean result = true;</span>

<span class="nc bnc" id="L1682" title="All 4 branches missed.">    if (includenames == null || includenames.isEmpty()) {</span>
<span class="nc bnc" id="L1683" title="All 4 branches missed.">      if (includes == null || includes.isEmpty()) {</span>
<span class="nc" id="L1684">        result = true;</span>
      } else {
<span class="nc" id="L1686">        result = pathMatches(includes, file.toPath());</span>
      }
    } else {
<span class="nc bnc" id="L1689" title="All 4 branches missed.">      if (includes == null || includes.isEmpty()) {</span>
<span class="nc" id="L1690">        result = nameMatches(includenames, name);</span>
      } else {
<span class="nc bnc" id="L1692" title="All 2 branches missed.">        result = pathMatches(includes, file.toPath())</span>
<span class="nc bnc" id="L1693" title="All 2 branches missed.">            || nameMatches(includenames, name);</span>
      }
    }
<span class="nc" id="L1696">    return result;</span>
  }

  /**
   * Checks whether the dependency defined by the file and
   * the module descriptor matches the exclude patterns
   * from the dependencyset.
   *
   * @param depSet the dependencyset
   * @param file the file
   * @param descriptor the module descriptor
   *
   * @return should the dependency be excluded
   */
  private boolean matchesExcludes(final DependencySet depSet, final File file,
      final JavaModuleDescriptor descriptor) {

<span class="nc bnc" id="L1713" title="All 2 branches missed.">    final String name = descriptor == null ? &quot;&quot; : descriptor.name();</span>

<span class="nc" id="L1715">    final List&lt;String&gt; excludes = depSet.getExcludes();</span>
<span class="nc" id="L1716">    final List&lt;String&gt; excludenames = depSet.getExcludeNames();</span>

<span class="nc" id="L1718">    boolean result = false;</span>

<span class="nc bnc" id="L1720" title="All 4 branches missed.">    if (excludenames == null || excludenames.isEmpty()) {</span>
<span class="nc bnc" id="L1721" title="All 4 branches missed.">      if (excludes == null || excludes.isEmpty()) {</span>
<span class="nc" id="L1722">        result = false;</span>
      } else {
<span class="nc" id="L1724">        result = pathMatches(excludes, file.toPath());</span>
      }
    } else {
<span class="nc bnc" id="L1727" title="All 4 branches missed.">      if (excludes == null || excludes.isEmpty()) {</span>
<span class="nc" id="L1728">        result = nameMatches(excludenames, name);</span>
      } else {
<span class="nc bnc" id="L1730" title="All 2 branches missed.">        result = pathMatches(excludes, file.toPath())</span>
<span class="nc bnc" id="L1731" title="All 2 branches missed.">            || nameMatches(excludenames, name);</span>
      }
    }
<span class="nc" id="L1734">    return result;</span>
  }

  /**
   * Checks if the path matches at least one of the patterns.
   * The pattern should be regex or glob, this is determined
   * by the prefix specified in the pattern.
   *
   * @param patterns the list of patterns
   * @param path the file path
   *
   * @return true if the path matches at least one of the patterns or
   *              if no patterns are specified
   */
  private boolean pathMatches(final List&lt;String&gt; patterns, final Path path) {
<span class="nc bnc" id="L1749" title="All 2 branches missed.">    for (final String pattern : patterns) {</span>
      final PathMatcher pathMatcher =
<span class="nc" id="L1751">          FileSystems.getDefault().getPathMatcher(pattern);</span>
<span class="nc bnc" id="L1752" title="All 2 branches missed.">      if (pathMatcher.matches(path)) {</span>
<span class="nc" id="L1753">        return true;</span>
      }
<span class="nc" id="L1755">    }</span>
<span class="nc" id="L1756">    return false;</span>
  }

  /**
   * Checks if the name matches at least one of the patterns.
   * The pattern should be regex only.
   *
   * @param patterns the list of patterns
   * @param name the name
   *
   * @return true if the name matches at least one of the patterns or
   *              if no patterns are specified
   */
  private boolean nameMatches(final List&lt;String&gt; patterns, final String name) {
<span class="nc bnc" id="L1770" title="All 2 branches missed.">    for (final String pattern : patterns) {</span>
<span class="nc" id="L1771">      final Pattern regexPattern = Pattern.compile(pattern);</span>
<span class="nc" id="L1772">      final Matcher nameMatcher = regexPattern.matcher(name);</span>
<span class="nc bnc" id="L1773" title="All 2 branches missed.">      if (nameMatcher.matches()) {</span>
<span class="nc" id="L1774">        return true;</span>
      }
<span class="nc" id="L1776">    }</span>
<span class="nc" id="L1777">    return false;</span>
  }

  /**
   * Process modules.
   *
   * @param cmdLine the command line builder
   *
   * @throws MojoExecutionException if any errors occurred
   */
  private void processModules(final CommandLineBuilder cmdLine)
      throws MojoExecutionException {
<span class="nc" id="L1789">    CommandLineOption opt = null;</span>
    // modulepath
<span class="nc bnc" id="L1791" title="All 2 branches missed.">    if (modulepath != null) {</span>
<span class="nc" id="L1792">      final StringBuilder path = new StringBuilder();</span>
<span class="nc" id="L1793">      final String pathElements = getPathElements();</span>
<span class="nc bnc" id="L1794" title="All 2 branches missed.">      if (!StringUtils.isBlank(pathElements)) {</span>
<span class="nc" id="L1795">        path.append(StringUtils.stripToEmpty(pathElements));</span>
      }
<span class="nc" id="L1797">      final String fileSets = getFileSets();</span>
<span class="nc bnc" id="L1798" title="All 2 branches missed.">      if (!StringUtils.isBlank(fileSets)) {</span>
<span class="nc bnc" id="L1799" title="All 2 branches missed.">        if (path.length() != 0) {</span>
<span class="nc" id="L1800">          path.append(File.pathSeparator);</span>
        }
<span class="nc" id="L1802">        path.append(StringUtils.stripToEmpty(fileSets));</span>
      }
<span class="nc" id="L1804">      final String dirSets = getDirSets();</span>
<span class="nc bnc" id="L1805" title="All 2 branches missed.">      if (!StringUtils.isBlank(dirSets)) {</span>
<span class="nc bnc" id="L1806" title="All 2 branches missed.">        if (path.length() != 0) {</span>
<span class="nc" id="L1807">          path.append(File.pathSeparator);</span>
        }
<span class="nc" id="L1809">        path.append(StringUtils.stripToEmpty(dirSets));</span>
      }
<span class="nc" id="L1811">      final String dependencySets = getDependencySets();</span>
<span class="nc bnc" id="L1812" title="All 2 branches missed.">      if (!StringUtils.isBlank(dependencySets)) {</span>
<span class="nc bnc" id="L1813" title="All 2 branches missed.">        if (path.length() != 0) {</span>
<span class="nc" id="L1814">          path.append(File.pathSeparator);</span>
        }
<span class="nc" id="L1816">        path.append(StringUtils.stripToEmpty(dependencySets));</span>
      }
<span class="nc bnc" id="L1818" title="All 2 branches missed.">      if (path.length() != 0) {</span>
<span class="nc" id="L1819">        opt = cmdLine.createOpt();</span>
<span class="nc" id="L1820">        opt.createArg().setValue(&quot;--module-path&quot;);</span>
<span class="nc" id="L1821">        opt.createArg().setValue(path.toString());</span>
      }
    }
    // addmodules
<span class="nc bnc" id="L1825" title="All 4 branches missed.">    if (addmodules != null &amp;&amp; !addmodules.isEmpty()) {</span>
<span class="nc" id="L1826">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1827">      opt.createArg().setValue(&quot;--add-modules&quot;);</span>
<span class="nc" id="L1828">      opt.createArg().setValue(</span>
<span class="nc" id="L1829">          addmodules.stream().collect(Collectors.joining(&quot;,&quot;)));</span>
    }
    // bindservices
<span class="nc bnc" id="L1832" title="All 2 branches missed.">    if (bindservices) {</span>
<span class="nc" id="L1833">      opt = cmdLine.createOpt();</span>
<span class="nc" id="L1834">      opt.createArg().setValue(&quot;--bind-services&quot;);</span>
    }
<span class="nc" id="L1836">  }</span>

  /**
   * Execute goal.
   *
   * @throws MojoExecutionException if any errors occurred
   */
  @Override
  public void execute() throws MojoExecutionException {

    // Init
<span class="nc" id="L1847">    init(TOOL_NAME, toolhome, TOOL_HOME_BIN); // from BaseToolMojo</span>

    // Check version
<span class="nc" id="L1850">    final JavaVersion toolJavaVersion = getToolJavaVersion();</span>
<span class="nc bnc" id="L1851" title="All 2 branches missed.">    if (toolJavaVersion == null</span>
<span class="nc bnc" id="L1852" title="All 2 branches missed.">        || !toolJavaVersion.atLeast(JavaVersion.JAVA_9)) {</span>
<span class="nc" id="L1853">      throw new MojoExecutionException(MessageFormat.format(</span>
          &quot;Error: At least {0} is required to use [{1}]&quot;, JavaVersion.JAVA_9,
          TOOL_NAME));
    }

    // Delete temporary directory if it exists
<span class="nc bnc" id="L1859" title="All 2 branches missed.">    if (temp != null) {</span>
<span class="nc bnc" id="L1860" title="All 2 branches missed.">      if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L1861">        getLog().debug(MessageFormat.format(</span>
            &quot;Temporary directory: [{0}]&quot;, temp));
      }
<span class="nc bnc" id="L1864" title="All 4 branches missed.">      if (temp.exists() &amp;&amp; temp.isDirectory()) {</span>
        try {
<span class="nc" id="L1866">          FileUtils.deleteDirectory(temp);</span>
<span class="nc" id="L1867">        } catch (IOException ex) {</span>
<span class="nc" id="L1868">          throw new MojoExecutionException(MessageFormat.format(</span>
              &quot;Error: Unable to delete temporary directory: [{0}]&quot;, temp), ex);
<span class="nc" id="L1870">        }</span>
      }
    }

    // Resolve and fetch project dependencies
<span class="nc" id="L1875">    projectDependencies = resolveDependencies();</span>
<span class="nc" id="L1876">    mainModuleDescriptor = fetchMainModuleDescriptor();</span>
    // final List&lt;File&gt; classpathElements = fetchClasspathElements();
    // final List&lt;File&gt; modulepathElements = fetchModulepathElements();
<span class="nc" id="L1879">    final Map&lt;File, String&gt; pathExceptions = fetchPathExceptions();</span>
<span class="nc bnc" id="L1880" title="All 4 branches missed.">    if (!pathExceptions.isEmpty() &amp;&amp; getLog().isWarnEnabled()) {</span>
<span class="nc" id="L1881">      getLog().warn(&quot;Found path exceptions: &quot; + pathExceptions.size()</span>
<span class="nc" id="L1882">          + System.lineSeparator()</span>
<span class="nc" id="L1883">          + pathExceptions.entrySet().stream()</span>
<span class="nc" id="L1884">              .map(entry -&gt; entry.getKey().toString()</span>
<span class="nc" id="L1885">                  + System.lineSeparator()</span>
<span class="nc" id="L1886">                  + entry.getValue())</span>
<span class="nc" id="L1887">              .collect(Collectors.joining(System.lineSeparator())));</span>
    }

    // Build command line and populate the list of the command options
<span class="nc" id="L1891">    final CommandLineBuilder cmdLineBuilder = new CommandLineBuilder();</span>
<span class="nc" id="L1892">    cmdLineBuilder.setExecutable(getToolExecutable().toString());</span>
<span class="nc" id="L1893">    processOptions(cmdLineBuilder);</span>
<span class="nc" id="L1894">    processModules(cmdLineBuilder);</span>
<span class="nc" id="L1895">    final List&lt;String&gt; optsLines = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1896">    optsLines.add(&quot;# &quot; + TOOL_NAME);</span>
<span class="nc" id="L1897">    optsLines.addAll(cmdLineBuilder.buildOptionList());</span>
<span class="nc bnc" id="L1898" title="All 2 branches missed.">    if (getLog().isDebugEnabled()) {</span>
<span class="nc" id="L1899">      getLog().debug(optsLines.stream()</span>
<span class="nc" id="L1900">          .collect(Collectors.joining(System.lineSeparator(),</span>
<span class="nc" id="L1901">              System.lineSeparator(), &quot;&quot;)));</span>
    }

    // Save the list of command options to the file
    // will be used in the tool command line
<span class="nc" id="L1906">    final Path cmdOptsPath = getBuildDir().toPath().resolve(OPTS_FILE);</span>
    try {
<span class="nc" id="L1908">      Files.write(cmdOptsPath, optsLines, getCharset());</span>
<span class="nc" id="L1909">    } catch (IOException ex) {</span>
<span class="nc" id="L1910">      throw new MojoExecutionException(MessageFormat.format(</span>
          &quot;Error: Unable to write command options to file: [{0}]&quot;,
          cmdOptsPath), ex);
<span class="nc" id="L1913">    }</span>
<span class="nc" id="L1914">    tempFiles.add(cmdOptsPath.toFile());</span>

    // Prepare command line with command options
    // specified in the file created early
<span class="nc" id="L1918">    final Commandline cmdLine = new Commandline();</span>
<span class="nc" id="L1919">    cmdLine.setExecutable(getToolExecutable().toString());</span>
<span class="nc" id="L1920">    cmdLine.createArg().setValue(&quot;@&quot; + cmdOptsPath.toString());</span>

    // Execute command line
<span class="nc" id="L1923">    int exitCode = 0;</span>
    try {
<span class="nc" id="L1925">      exitCode = execCmdLine(cmdLine); // from BaseToolMojo</span>
<span class="nc" id="L1926">    } catch (CommandLineException ex) {</span>
<span class="nc" id="L1927">      throw new MojoExecutionException(MessageFormat.format(</span>
          &quot;Error: Unable to execute [{0}] tool&quot;, TOOL_NAME), ex);
<span class="nc" id="L1929">    }</span>
<span class="nc bnc" id="L1930" title="All 2 branches missed.">    if (exitCode != 0) {</span>
<span class="nc bnc" id="L1931" title="All 2 branches missed.">      if (getLog().isErrorEnabled()) {</span>
<span class="nc" id="L1932">        getLog().error(System.lineSeparator()</span>
            + &quot;Command options was: &quot;
<span class="nc" id="L1934">            + System.lineSeparator()</span>
<span class="nc" id="L1935">            + optsLines.stream()</span>
<span class="nc" id="L1936">                .collect(Collectors.joining(System.lineSeparator())));</span>
      }
<span class="nc" id="L1938">      throw new MojoExecutionException(MessageFormat.format(</span>
          &quot;Error: Tool execution failed [{0}] with exit code: {1}&quot;, TOOL_NAME,
<span class="nc" id="L1940">          exitCode));</span>
    }

    // Delete temporary files
<span class="nc bnc" id="L1944" title="All 2 branches missed.">    for (final File tempFile : tempFiles) {</span>
      try {
<span class="nc" id="L1946">        FileUtils.forceDelete(tempFile);</span>
<span class="nc" id="L1947">      } catch (IOException ex) {</span>
<span class="nc" id="L1948">        throw new MojoExecutionException(MessageFormat.format(</span>
            &quot;Error: Unable to delete temporary file: [{0}]&quot;, tempFile), ex);
<span class="nc" id="L1950">      }</span>
<span class="nc" id="L1951">    }</span>

<span class="nc" id="L1953">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>